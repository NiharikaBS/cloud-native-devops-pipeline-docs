Containerizing a Java-based Microservice Using Gradle 
This guide outlines the Dockerfile setup for containerizing a Java microservice built with Gradle. It uses a two-stage build approach to ensure minimal image size and optimized builds.

Stage 1: Build Phase
In the first stage, a JDK image is used to compile the application and generate the required build artifacts.

Base Image
Start with eclipse-temurin:21-jdk, a stable OpenJDK distribution maintained by the Eclipse Foundation.

Working Directory
Set the container's working directory to /usr/src/app/.

Preparing Gradle
Copy Gradle wrapper scripts, settings, and build configuration files.

Copy the .gradle/ directory which contains custom Gradle scripts and settings.

Dependency Preparation
Make the Gradle wrapper executable using chmod.

Execute the wrapper to initialize Gradle.

Run downloadRepos to pre-fetch and cache project dependencies.

Application Source
Copy the full application source into the container.

Protocol buffer definitions are added from ./pb to ./proto.

Build Output
Execute installDist with a custom proto directory. This creates a full distribution of the service under build/install.

Stage 2: Runtime Phase
The second stage produces a minimal final image that contains only the runtime dependencies.

Base Image
Use eclipse-temurin:21-jre to reduce image size, containing only what's needed to run the application.

Application Setup
Copy the complete build output from the first stage into the runtime image.

Environment Configuration
Define a default port using the AD_PORT environment variable.

Entrypoint
The container runs the prebuilt application using the entry script generated by Gradle:
./build/install/opentelemetry-demo-ad/bin/Ad
  
Key Benefits:
Multi-stage builds reduce the final image size by excluding unnecessary build tools.
Build artifacts are reproducible and portable.
Dependency resolution and protobuf integration are managed as part of the container build, enabling fully automated setup in CI/CD.
